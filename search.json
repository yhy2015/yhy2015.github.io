[{"title":"dealloc","url":"%2F2024%2F02%2F01%2FiOS%2Fdealloc%2F","content":"\n[好的文章](http://blog.jobbole.com/65028/)\n>http://clang.llvm.org/docs/AutomaticReferenceCounting.html#dealloc\nhttp://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/\n\n``` objc\n- (void)dealloc;\n```\n***调用时机***\n> A class may provide a method definition for an instance method named dealloc. This method will be called after the final release of the object but before it is deallocated or any of its instance variables are destroyed. The superclass’s implementation of dealloc will be called automatically when the method returns.\n\n大概意思是：dealloc方法在最后一次release后被调用，但此时实例变量（Ivars）并未释放，父类的dealloc的方法将在子类dealloc方法返回后自动调用\n****\n\n> Subsequent messages to the receiver may generate an error indicating that a message was sent to a deallocated object (provided the deallocated memory hasn’t been reused yet).\nYou override this method to dispose of resources other than the object’s instance variables, for example:\n重写这个方法可以处理除了对象的实例变量之外的其他资源\n\n``` \n- (void)dealloc {\n    free(myBigBlockOfMemory);\n }\n```\n>In an implementation of dealloc, do not invoke the superclass’s implementation. You should try to avoid managing the lifetime of limited resources such as file descriptors using dealloc\nYou never send a dealloc message directly. Instead, an object’s dealloc\nmethod is invoked by the runtime. See [Advanced Memory Management Programming Guide for more details.\narc环境下不要在dealloc方法中调用父类的dealloc实现，不要手动调用dealloc方法\n\n<br>\n>Special Considerations\nWhen not using ARC, your implementation of dealloc must invoke the superclass’s implementation as its last instruction.\nmac环境下，重写dealloc方法，要在子类实现的最后一行调用父类delloc实现\n\nhttps://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/\n\n","tags":["iOS"]},{"title":"KVO底层原理","url":"%2F2024%2F01%2F19%2FiOS%2FKVO%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%2F","content":"``` objc\n  // KVO怎么实现\n    // KVO的本质就是监听一个对象有没有调用set方法\n    // 重写这个方法\n    // 监听方法本质:并不需要修改方法的实现,仅仅想判断下有没有调用\n``` \n``` objc\n  // KVO底层实现\n    // 1.自定义NSKVONotifying_Person子类\n    // 2.重写setName,在内部恢复父类做法,通知观察者\n    // 3.如何让外界调用自定义Person类的子类方法,修改当前对象的isa指针,指向NSKVONotifying_Person\n```\n\n###### KVO基本原理：\n1、kvo是基于runtime机制实现的\n2、当某个类的属性对象第一次被观察时，系统就会在运行期动态的创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter方法，派生类在被重写的setter方法内实现真正的通知机制\n3、如果原类为Person，那么生成的派生类名为NSKVONotifying_Person\n4、每个类对象中都有一个isa指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的派生类的setter方法\n5、键值观察通知依赖于NSObject的两个方法：willChangeValueForKey:和didChangeValueForKey:在一个被观察属性发生改变之前，willChangeValueForKey:会被调用，这就会记录旧的值，而当改变发生后，didChangeValueForKey:会被调用，继而observeValueForKey:ofObject:change:context: 也会被调用。\n##### KVO深入原理：\n1、Apple使用了isa混写(isa-swizzling)来实现KVO，当观察对象A时，KVO机制动态创建一个新的名为：NSKVONotifying_A的新类，该类继承自对象A的本类，且KVO为NSKVONotifying_A重写观察属性的setter方法，setter方法会负责在调用原setter方法之前和之后，通知所有观察对象属性值的更改情况。\n2、NSKVONotifying_A类剖析：在这个过程，被观察对象的isa指针从只想原来的A类，被KVO机制修改为指向系统新创建的自雷NSKVONotifying_A类，来实现当前类属性值改变的监听。\n3、所以当我们从应用层面上来看，完全没有意识到有新的类的除夕拿，这是系统“隐藏”了对KVO的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为NSKVONotifying_A的类，就会发现系统运行到注册KVO的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为NSKVONotifying_A的中间类，并指向这个中间类了。\n4、（isa指针的作用：每个对象都有isa指针，指向该对象的类，它告诉Runtime系统这个对象的类是什么。所以对象注册为观察者时，isa指针指向新子类，那么这个被观察的对象就神奇的变成新子类的对象（或实例）了）因而在该对象上对setter的调用就会调用已重写的setter，从而激活键值通知机制。\n5、子类setter方法剖析:KVO的键值观察通知依赖于NSObject的两个方法：willChangeValueForKey:和didChangeValueForKey:，在存取数值的齐纳后分别调用2个方法，被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该keyPath的属性值即将变更，当改变发生后，didChangeValueForKey:被调用，通知系统该keyPath的属性值已经变更，之后observeValueForKey:ofObject:change:context: 也会被调用，且重写观察属性的setter方法这种集成法师的注入实在运行时而不是在编译时实现的。\n![668737-64700c5033f04439.jpeg](https://upload-images.jianshu.io/upload_images/1391187-b6c0cd93ac04863c.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)\n"},{"title":"category和extension","url":"%2F2023%2F12%2F04%2FiOS%2Fcategory-%E5%92%8C-extension%2F","content":"\n``` objc\nstruct objc_category {\n    //分类名\n    char * _Nonnull category_name                            OBJC2_UNAVAILABLE;\n    //类名\n    char * _Nonnull class_name                               OBJC2_UNAVAILABLE;\n    //实例方法\n    struct objc_method_list * _Nullable instance_methods     OBJC2_UNAVAILABLE;\n  //类方法\n    struct objc_method_list * _Nullable class_methods        OBJC2_UNAVAILABLE;\n  //遵守的协议\n    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;\n}      \n```\n#### 由分类结构可知，分类可添加实例方法，类方法，遵守协议，不可添加实例变量\n\n##### category的主要作用:*\n1、 为已经存在的类添加方法\n2、 可以把类的实现分开在几个不同的文件里面。这样做有几个显而易见的好处，a)可以减少单个文件的体积 b)可以把不同的功能组织到不同的category里 c)可以由多个开发者共同完成一个类 d)可以按需加载想要的category 等等。\n3、 声明私有方法\n\n\n##### 注意：\n1)、category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加完成之后，类的方法列表里会有两个methodA\n2)、category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休^_^，殊不知后面可能还有一样名字的方法。\n\n\n##### extension和category对比\nextension看起来很像一个匿名的category，但是extension和有名字的category几乎完全是两个东西。 extension在编译期决议，它就是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如NSString添加extension\n\n##### 但是category则完全不一样，它是在运行期决议的，extension是运行期，作为类的一部分。\n就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。\n","tags":["iOS"]},{"title":"APP 启动","url":"%2F2023%2F11%2F24%2FiOS%2FApp%20%E5%90%AF%E5%8A%A8%2F","content":"\n##### 一、Start\n1.加载二进制\n2.检查沙箱\n3.Objective-C Class Load Initialize\n4._attribute_((constructor))函数，C++全局对象构造函数\n5.加载必要的资源（info.plist）,并显示启动页\n6.main函数\n``` objc\nint main(int argc, char *argv[])\n{\n    @autoreleasepool {\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n```\n重点分析下main函数，\n1.函数的参数argc和argv包含有关在启动时传递给可执行文件的命令行参数的信息。经打印，argv为改app二进制地址信息\n2.创建了一个autoreleasepool，当应用终止时,管理应用内存\n<!--more-->\n3.UIApplicationMain函数中实例化UIApplication对象,AppDelegate对象，并将AppDelegate设置为UIApplication对象的代理，还要开启runloop，加载nib，info.plist文件。UIApplicationMain接受四个参数，第一二个接受main参数，第三个默认为nil，这时初始化UIApplication类，你可以传个UIApplication的子类，重写UIApplication里面的方法。第四个参数传UIApplication的代理。\n###### 以上初始化后，调用- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n![ios-4-app-launch-flow.png](http://upload-images.jianshu.io/upload_images/1391187-778e10a697587c17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)\n##### 二、应用事件传递\n ![image.png](http://upload-images.jianshu.io/upload_images/1391187-47bcd6e734f7a82f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)\n当一个硬件事件(触摸/锁屏/摇晃/加速等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收， 随后由mach port 转发给需要的App进程。\n苹果注册了一个 Source1 (基于 mach port 的) 来接收系统事件，通过回调函数触发Sourece0（所以UIEvent实际上是基于Source0的），调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。\n_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。\n##### 三、app的五种状态\n![high_level_flow_2x.png](http://upload-images.jianshu.io/upload_images/1391187-d8af7799c6bc3920.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400)\n* Not running\n`The app has not been launched or was running but was terminated by the system.`\n未启动或被系统终止运行\n* Inactive\n`The app is running in the foreground but is currently not receiving events. (It may be executing other code though.) An app usually stays in this state only briefly as it transitions to a different state.`\n在前台但是已经不能接受事件，这是转向其他状态的一种过渡状态(临时)\n* Active\n`The app is running in the foreground and is receiving events. This is the normal mode for foreground apps.`\n在前台运行并能接受事件\n* Background\n`The app is in the background and executing code. Most apps enter this state briefly on their way to being suspended. However, an app that requests extra execution time may remain in this state for a period of time. In addition, an app being launched directly into the background enters this state instead of the inactive state. For information about how to execute code while in the background`\napp在后台并能执行代码，需要申请后台权限(播放音频，位置更新，voip等)\n* Suspended\n`The app is in the background but is not executing code. The system moves apps to this state automatically and does not notify them before doing so. While suspended, an app remains in memory but does not execute any code.\nWhen a low-memory condition occurs, the system may purge suspended apps without notice to make more space for the foreground app.`\napp在后台但不执行代码，一般app进入后台都会到这个状态。这个状态下app仍然占据内存空间。当内存过少时，系统会自动清除暂停的应用程序\n##### 四.app架构(MVC)\n![image.png](http://upload-images.jianshu.io/upload_images/1391187-6be27089f635cffa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)\n[引用](https://oleb.net/blog/2011/06/app-launch-sequence-ios/)\n","tags":["iOS"]},{"title":"计划","url":"%2F2023%2F11%2F23%2FiOS%E6%BA%90%E7%A0%81%2F%E8%AE%A1%E5%88%92%2F","content":"\n0.YYCache\n1.YYImage - 2天  两天\n2.afn - 2天\n3.YYmodel - 2天\n4.mjrefresh - 2天\n","tags":["iOS源码"]},{"title":"CGRect","url":"%2F2023%2F11%2F23%2FiOS%2Fcgrect%2F","content":"``` objc\nself.frame = (CGRect){self.arrowPoint, 1, 1};//用大括号构造CGRect\n```\n","tags":["iOS"]},{"title":"字体阴影效果","url":"%2F2023%2F11%2F19%2FiOS%2F%E5%AD%97%E4%BD%93%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C%2F","content":"\n##### 1、最简单的方式（最简单的效果）\nUILabel只需要设置shadowOffset和shadowColor两个属性即可\n``` objc\nUILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(50, 50, 100, 100)];\nlabel.text = @\"文字\";\nlabel.shadowOffset = CGSizeMake(1, 1);\nlabel.shadowColor = [UIColor redColor];\n[self.view addSubview:label];\n```\n###### 2、NSAttributedString\n自定义一个view，重写drawRect:方法绘制文本\n``` objc\n- (void)drawRect:(CGRect)rect{\n    NSShadow *shadow = [[NSShadow alloc]init];\n    shadow.shadowBlurRadius = 1.0;\n    shadow.shadowOffset = CGSizeMake(1, 1);\n    shadow.shadowColor = [UIColor redColor];\n    \n    NSDictionary *dict = @{NSFontAttributeName:[UIFont systemFontOfSize:16.f],\n                           NSForegroundColorAttributeName: [UIColor cyanColor],\n                           NSShadowAttributeName : shadow,//设置阴影属性\n                           NSVerticalGlyphFormAttributeName: @(0)\n                           };\n    //_text 要绘制的文本\n    [_text drawInRect:self.bounds withAttributes:dict];\n}\n```\n###### 以后继续补充\n","tags":["iOS"]},{"title":"self","url":"%2F2023%2F10%2F19%2FiOS%2Fself%2F","content":"一、\nself和_cmd是隐藏参数，在编译期被插入实现代码。\nself：self是类的一个隐藏参数，每个方法的实现的第一个参数即为self。指向消息的接受者target的对象类型，作为一个占位参数，消息传递成功后self将指向消息的receiver。\n\n二、\nNSObject类中源码实现\n``` objc\n+ (id)self {\n    return (id)self;\n}\n\n- (id)self {\n    return self;\n}\n```\n>对于一个类对象来讲self返回的其实是一个指向objc_class对象的指针的地址；\n对于一个实例对象来讲self返回的其实是一个指向objc_object对象的指针地址，\n","tags":["iOS"]},{"title":"TextView-placeHolder","url":"%2F2023%2F10%2F14%2FiOS%2FTextView-placeHolder%2F","content":"TextView有placeHolderLabel这个私有属性，我们可以用万能的kvc调用\n```\n#import \"ViewController.h\"\n#import <objc/runtime.h>\n#import <objc/message.h>\n\n@interface ViewController ()\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n　　// 通过运行时，发现UITextView有一个叫做“_placeHolderLabel”的私有变量\n    unsigned int count = 0;\n    Ivar *ivars = class_copyIvarList([UITextView class], &count);\n\n    for (int i = 0; i < count; i++) {\n        Ivar ivar = ivars[i];\n        const char *name = ivar_getName(ivar);\n        NSString *objcName = [NSString stringWithUTF8String:name];\n        NSLog(@\"%d : %@\",i,objcName);\n    }\n\n}\n@end\n````\n所以我们只需以下方式就可以给textView添加placeholder\n\n```\n- (void)setupTextView\n{\n    UITextView *textView = [[UITextView alloc] initWithFrame:CGRectMake(0, 100, [UIScreen mainScreen].bounds.size.width, 100];\n    [textView setBackgroundColor:[UIColor greenColor]];\n    [self.view addSubview:textView];\n\n    // _placeholderLabel\n    UILabel *placeHolderLabel = [[UILabel alloc] init];\n    placeHolderLabel.text = @\"请输入内容\";\n    placeHolderLabel.numberOfLines = 0;\n    placeHolderLabel.textColor = [UIColor lightGrayColor];\n    [placeHolderLabel sizeToFit];\n    [textView addSubview:placeHolderLabel];//这句很重要不要忘了\n\n    // same font\n    textView.font = [UIFont systemFontOfSize:13.f];\n    placeHolderLabel.font = [UIFont systemFontOfSize:13.f];\n\n    [textView setValue:placeHolderLabel forKey:@\"_placeholderLabel\"];\n}\n```\n","tags":["iOS"]},{"title":"OC方法调用流程及消息转发","url":"%2F2023%2F09%2F19%2FiOS%2FOC%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%8F%8A%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%2F","content":"\n>objc_msgForward函数的作用\nobjc_msgForward是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。\n***\n>objc_msgSend(obj,foo)解释：\n将foo消息发送给obj对象，首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用_objc_msgForward函数指针代替 IMP 。最后，执行这个 IMP 。\n>具体实现：\n当向一般对象发送消息时，调用objc_msgSend；当向super发送消息时，调用的是objc_msgSendSuper； 如果返回值是一个结构体，则会调用objc_msgSend_stret或objc_msgSendSuper_stret。\n0.1-检查target是否为nil。如果为nil，直接cleanup，然后return。(这就是我们可以向nil发送消息的原因。) 如果方法返回值是一个对象，那么发送给nil的消息将返回nil；如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者long long的整型标量，发送给nil的消息将返回0；如果方法返回值为结构体,发送给nil的消息将返回0。结构体中各个字段的值将都是0；如果方法的返回值不是上述提到的几种情况，那么发送给nil的消息的返回值将是未定义的。\n 0.2-如果target非nil，在target的Class中根据Selector去找IMP。（因为同一个方法可能在不同的类中有不同的实现，所以我们需要依赖于接收者的类来找到的确切的实现）。\n1-首先它找到selector对应的方法实现: *1.1-在target类的方法缓存列表里检查有没有对应的方法实现，有的话，直接调用。 *1.2-比较请求的selector和类方法列表中的selector，对应的话，直接调用。 *1.3-比较请求的selector和父类方法列表，父类的父类，直至根类，如果有对应，则直接调用。（方法重写拦截父类方法的原理） 2-调用方法实现，并将接收者对象及方法的所有参数传给它。 3-最后，将实现函数的返回值作为自己的返回值。\n***\n![image.png](http://upload-images.jianshu.io/upload_images/1391187-96ab1bae666f6176.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n>_objc_msgForward在进行消息转发的过程中会涉及以下这几个方法：\n1、resolveInstanceMethod:方法 (或 resolveClassMethod:)。\n2、forwardingTargetForSelector:方法\n3、methodSignatureForSelector:方法\n4、forwardInvocation:方法\n5、doesNotRecognizeSelector: 方法\n***\n>我们所说的三大挽救措施就是实现其中的方法\n```\n//当某个对象不能接受某个selector时，向对象所属的类动态添加所需的selector：\n+ (BOOL)resolveInstanceMethod:(SEL)sel{\n    if (sel == @selector(eat)) {\n        class_addMethod([Person class], sel, (IMP)eat, \"\");\n        //返回Yes将不再调用该方法下面的方法\n        return Yes;\n    }\n    return [super resolveInstanceMethod:sel];\n}\nvoid eat(){\n    NSLog(@\"eat\");\n}\n```\n```\n//当某个对象不能接受某个selector时，将对该selector的调用转发给另一个对象\n- (id)forwardingTargetForSelector:(SEL)aSelector{\n    if (aSelector == @selector(eat1)) {\n//无法处理的selector转 发给另一个对象\n        return [[Student alloc] init];\n    }\n    return [super forwardingTargetForSelector:aSelector];\n}\n```\n```\n//为另一个类实现的消息创建一个有效的方法签名\n这个不懂，。。。。\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector{\n    NSString *sel = NSStringFromSelector(selector);\n    if ([sel rangeOfString:@\"set\"].location == 0){\n        return [NSMethodSignature signatureWithObjCTypes:\"v@:@\"];\n    }else{\n        return [NSMethodSignature signatureWithObjCTypes:\"@@:\"];\n    }\n}\n```\n","tags":["iOS"]},{"title":"Strong-Weak-Dance","url":"%2F2023%2F09%2F12%2FiOS%2FStrong-Weak-Dance%2F","content":"[链接](http://ios.jobbole.com/84310/)\n[执行 block 的过程中，block 被释放了怎么办](https://stackoverflow.com/questions/12272783/what-happens-when-a-block-is-set-to-nil-during-its-execution)\n","tags":["iOS"]},{"title":"VSCode插件markdown快捷键","url":"%2F2023%2F09%2F07%2Ftools%2FVSCode%E6%8F%92%E4%BB%B6markdown%E5%BF%AB%E6%8D%B7%E9%94%AE%2F","content":"\n#### 插件All in One markdown 用法\n#####  加粗\n`Ctrl + B`\n##### 斜体\n`Ctrl + I `\t\n##### 删除线\n`Alt + S`\t \n##### 加大字号\n`Ctrl + Shift + ]` \b \n##### 减小字号\n`Ctrl + Shift + [`\n##### 打开预览界面\n`Ctrl + Shift + V` \n\n","tags":["tool"]},{"title":"autoreleasepool","url":"%2F2023%2F09%2F07%2FiOS%2Fautoreleasepool%2F","content":"\nhttp://www.jianshu.com/p/32265cbb2a26\n","tags":["iOS"]},{"title":"像素对齐","url":"%2F2023%2F09%2F07%2FiOS%2F%E5%83%8F%E7%B4%A0%E5%AF%B9%E9%BD%90%2F","content":"图片在缩放和像素不对齐\n这两种情况下，GPU 需要再做额外的计算。它需要将源纹理上多个像素混合起来，生成一个用来合成的值。\n当所有的像素都是对齐的时候，GPU 只剩下很少的工作要做。\n\nios内存中一个像素占用4字节空间。比如一个1000 * 1000像素的图片解压后在内存中占用1000 * 1000 * 4 / (1024 * 1024) = 4Mb\n1像素占用4字节（1个像素用argb来表示，rgb都有256种形式，argb每一种都用一个字节表示，故需要四字节）\n","tags":["iOS"]},{"title":"内存分布","url":"%2F2023%2F09%2F07%2FiOS%2F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%2F","content":"\nhttp://www.cnblogs.com/mddblog/p/4405165.html\n战队全长待\n","tags":["iOS"]},{"title":"加密","url":"%2F2023%2F09%2F07%2FiOS%2F%E5%8A%A0%E5%AF%86%2F","content":"\nDES AES RSA\n\n\nDES，AES有两种模式，ECB（Electronic Code Book，电子密码本）模式和CBC（Cipher Block Chaining，加密块链）模式\n\n","tags":["iOS"]},{"title":"接触到的新框架","url":"%2F2023%2F09%2F07%2FiOS%2F%E6%8E%A5%E8%A7%A6%E5%88%B0%E7%9A%84%E6%96%B0%E6%A1%86%E6%9E%B6%2F","content":"\n1、Firebase \n无需管理基础架构，快速构建您的应用. Firebase SDK（如Analytics、数据库、通知和崩溃报告）可让您快速迁移并专注于您的用户。\n2、SimulatorStatusMagic，在模拟器上修改状态栏的工具，比如时间，蓝牙\n3、FlurrySDK，雅虎统计 错误分析\n4.Fabric: 错误统计，自动分发(整合到谷歌旗下)\n","tags":["iOS"]},{"title":"线程占用内存","url":"%2F2023%2F09%2F07%2FiOS%2F%E7%BA%BF%E7%A8%8B%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98%2F","content":"![Paste_Image.png](http://upload-images.jianshu.io/upload_images/1391187-f4d56c5870c6dd34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","tags":["iOS"]},{"title":"获取一个类的所有变量和方法","url":"%2F2023%2F09%2F07%2FiOS%2F%E8%8E%B7%E5%BE%97%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%98%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95%2F","content":"\n获取一个类的所有方法\n``` objc\n unsigned int methodCount;\n Method *methodList = class_copyMethodList(currentClass, &methodCount);\n for (NSInteger i = 0; i < methodCount; i++) {\n         Method method = methodList[i];\n         NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method))\n                                                          encoding:NSUTF8StringEncoding]\n         NSLog(@\"%@\",methodName);\n   }\n```\n获取一个类的所有变量\n``` objc\nunsigned int count = 0;\nIvar *ivars = class_copyIvarList([currentClass class], &count);\n\nfor (int i = 0; i < count; i++) {\n        Ivar ivar = ivars[i];\n        const char *name = ivar_getName(ivar);\n        NSString *objcName = [NSString stringWithUTF8String:name];\n        NSLog(@\"%d : %@\",i,objcName);\n    }\n```\n","tags":["iOS"]},{"title":"解决block循环引用","url":"%2F2023%2F09%2F07%2FiOS%2F%E8%A7%A3%E5%86%B3block%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%2F","content":"\n``` objc\n因为block一般都在对象内部声明.. 如果在block内部使用了当前对象的属性,就会造成循环引用(block拥有当前对象的地址,而当前对象拥有block的地址),而引起内存泄露,block和当前对象都无法释放.\n\n@weakify 将当前对象声明为weak.. 这样block内部引用当前对象,就不会造成引用计数+1可以破解循环引用\n\n@strongify 相当于声明一个局部的strong对象,等于当前对象.可以保证block调用的时候,内部的对象不会释放\n\n```\n#####AFN ，SDWebImage\n``` objc\n__weak __typeof(self)weakSelf = self;\nblock = ^(){\n    __strong __typeof(weakSelf)strongSelf = weakSelf;\n    // strongSelf.property\n};\n```\n##### YYKit库里用到\n``` objc\n/**\n Synthsize a weak or strong reference.\n \n Example:\n    @weakify(self)\n    [self doSomething^{\n        @strongify(self)\n        if (!self) return;\n        ...\n    }];\n\n */\n#ifndef weakify\n    #if DEBUG\n        #if __has_feature(objc_arc)\n        #define weakify(object) autoreleasepool{} __weak __typeof__(object) weak##_##object = object;\n        #else\n        #define weakify(object) autoreleasepool{} __block __typeof__(object) block##_##object = object;\n        #endif\n    #else\n        #if __has_feature(objc_arc)\n        #define weakify(object) try{} @finally{} {} __weak __typeof__(object) weak##_##object = object;\n        #else\n        #define weakify(object) try{} @finally{} {} __block __typeof__(object) block##_##object = object;\n        #endif\n    #endif\n#endif\n\n#ifndef strongify\n    #if DEBUG\n        #if __has_feature(objc_arc)\n        #define strongify(object) autoreleasepool{} __typeof__(object) object = weak##_##object;\n        #else\n        #define strongify(object) autoreleasepool{} __typeof__(object) object = block##_##object;\n        #endif\n    #else\n        #if __has_feature(objc_arc)\n        #define strongify(object) try{} @finally{} __typeof__(object) object = weak##_##object;\n        #else\n        #define strongify(object) try{} @finally{} __typeof__(object) object = block##_##object;\n        #endif\n    #endif\n#endif\n```\n","tags":["iOS"]},{"title":"离屏渲染","url":"%2F2023%2F09%2F07%2FiOS%2F%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%EF%BC%88Offscreen-Rendering%EF%BC%89%2F","content":"\n直接将图层合成到帧的缓冲区中\n离屏渲染\n离屏渲染可以被 Core Animation 自动触发，或者被应用程序强制触发。\n屏幕外的渲染会合并/渲染图层树的一部分到一个新的缓冲区，然后该缓冲区被渲染到屏幕上。\n离屏渲染合成计算是非常昂贵的, 但有时你也许希望强制这种操作。一种好的方法就是缓存合成的纹理/图层。\nGPU 第一次会混合所有图层到一个基于新的纹理的位图缓存上，然后使用这个纹理来绘制到屏幕上。\n现在，当这些图层一起移动的时候，GPU 便可以复用这个位图缓存，并且只需要做很少的工作。\n","tags":["iOS"]},{"title":"编码","url":"%2F2023%2F09%2F07%2FiOS%2F%E7%BC%96%E7%A0%81%2F","content":"\n[CocoaSecurity](https://github.com/kelp404/CocoaSecurity)常用框架\n[base64](http://www.cnblogs.com/mddblog/p/5512708.html)：\nBase64编码要求把3个8位字节（3*8=24）转化为4个6位的字节（4*6=24），之后在6位的前面补两个0，形成8位一个字节的形式，这样每一个字节的有效位为6位，则取值范围0~630 ~ (2^6 - 1)。如果最后剩下的字符不到3个字节，则用0填充，输出字符使用'='，因此我们看到Base64末尾会有1到2个'='。另外标准还要求每76个字符要插入换行(不过，这个视具体情况定)。\n\n    [[NSData alloc] initWithBase64EncodedData:data options:0];\n外对于参数NSDataBase64EncodingOptions选项，有多种取值\nNSDataBase64Encoding64CharacterLineLength：每64个字符插入\\r或\\n\nNSDataBase64Encoding76CharacterLineLength：每76个字符插入\\r或\\n，标准中有要求是76个字符要换行，不过具体还是自己定\nNSDataBase64EncodingEndLineWithCarriageReturn：插入字符为\\r\nNSDataBase64EncodingEndLineWithLineFeed：插入字符为\\n\n前两个选项为是否允许插入字符，以及多少个字符长度插入，两个可以选其一或者都不选。后两个选项代表要插入的具体字符。比如我们想76个字符后插入一个\\r则可以NSDataBase64Encoding76CharacterLineLength | NSDataBase64EncodingEndLineWithCarriageReturn。而在上面举的例子中选项为0，则代表不插入字符。\n\n","tags":["iOS"]},{"title":"设计模式-day1","url":"%2F2023%2F09%2F07%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-day1%2F","content":"#### 好的代码\n- 可维护\n  要改，只需更改要改之处\n- 可复用\n  如果后面有用到，可以直接复用\n- 可扩展\n 若要加功能,只需另外加入即可，无需更改之前代码\n- 灵活性好\n  支持多种方式\n\n#### 面向对象的好处\n通过封装 继承 多态把程序的耦合度降低,使得程序更加的灵活,容易修改,并且易于复用","tags":["设计模式"]},{"title":"野指针-僵尸对象","url":"%2F2023%2F09%2F07%2FiOS%2F%E9%87%8E%E6%8C%87%E9%92%88-%E5%83%B5%E5%B0%B8%E5%AF%B9%E8%B1%A1%2F","content":">内存回收的本质.\n1、申请1块空间,实际上是向系统申请1块别人不再使用的空间.\n2、释放1块空间,指的是占用的空间不再使用,这个时候系统可以分配给别人去使用.\n3、在这个内存空间分配给别人之前，数据还是存在的.\n\n野指针 --  指指向垃圾内存的指针。指针指向的对象引用计数为0，已被标记为可回收资源\n僵尸指针：野指针的一种，即该指针指向的对象已经被释放，但是却没有对当前指针赋值为nil。\n僵尸对象 -- 引用计数为0，做占用内存空间可被分配的对象（已经被释放的对象）\n\n如何避免僵尸对象报错.\n当1个指针变为野指针以后. 就把这个指针的值设置为nil\n","tags":["iOS"]},{"title":"绘制阴影图片","url":"%2F2023%2F08%2F17%2FiOS%2F%E7%BB%98%E5%88%B6%E9%98%B4%E5%BD%B1%E5%9B%BE%E7%89%87%2F","content":"\n##### UIImage 分类\n\n```objc\n+ (UIImage *)imageWithSize:(CGSize)size drawBlock:(void (^)(CGContextRef context))drawBlock {\n    if (!drawBlock) return nil;\n    UIGraphicsBeginImageContextWithOptions(size, NO, 0);\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    if (!context) return nil;\n    drawBlock(context);\n    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    return image;\n}\n```\n\n##### 调用方法\n\n```objc\nUIImage *shadowImg = [UIImage imageWithSize:CGSizeMake(1, 3) drawBlock:^(CGContextRef context) {\n            CGContextSetFillColorWithColor(context, [UIColor blackColor].CGColor);\n            CGContextSetShadowWithColor(context, CGSizeMake(0, 0.4), 2, [UIColor colorWithWhite:0 alpha:0.08].CGColor);\n            CGContextAddRect(context, CGRectMake(-2, -2, 4, 2));\n            CGContextFillPath(context);\n        }];\n```\n\n##### 一般将上述生成图片方法写在子线程(比如可以在 dispatch_once 里调用)\n\n```objc\nstatic dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        ....\n    });\n```\n","tags":["iOS"]},{"title":"hexo命令","url":"%2F2023%2F08%2F16%2Fhexo%2Fhexo%2F","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n*这些命令需要在hexo配置文件夹运行*\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","tags":["hexo"]},{"title":"签名","url":"%2F2023%2F08%2F15%2FiOS%2F%E7%AD%BE%E5%90%8D%2F","content":"\n[签名](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)\nMD5、SHA1、SHA256、SHA512、HMAC实现\n","tags":["iOS"]},{"title":"Object，Class","url":"%2F2023%2F08%2F14%2FiOS%2FObject%EF%BC%8CClass%2F","content":"一、Object (id )结构体\n``` objc\ntypedef struct objc_object *id;\n\nstruct objc_object {\n    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;\n};\n```\n二、class结构体(isa类型)\n``` objc\ntypedef struct objc_class *Class;\n\nstruct objc_class {\n    Class isa;\n\n#if !__OBJC2__\n    Class super_class                 ;  // 父类\n\n    const char *name                       ;  // 类名\n    long version                           ;  // 类的版本信息，默认为0\n    long info                              ;  // 类信息，供运行期使用的一些位标识\n\n    long instance_size                     ;  // 类的实例变量大小\n    struct objc_ivar_list *ivars           ;  // 类的成员变量链表\n\n    struct objc_method_list **methodLists  ;  // 方法定义的链表\n    struct objc_cache *cache               ;  // 方法缓存\n\n    struct objc_protocol_list *protocols   ;  // 协议链表\n#endif\n\n} OBJC2_UNAVAILABLE;\n```\n去除掉OBJC1信息，看到与object完全一样\n``` objc\nstruct objc_class {\n    Class isa;\n}\n```\n三、元类\n因为类也是一个对象，那它也必须是另一个类的实列，这个类就是元类 (metaclass)。*元类保存了类方法的列表(类保存方法列表)。*当一个类方法被调用时，元类会首先查找它本身是否有该类方法的实现，如果没有，则该元类会向它的父类查找该方法，直到一直找到继承链的头。\n\n元类 (metaclass) 也是一个对象，那么元类的 isa 指针又指向哪里呢？为了设计上的完整，所有的元类的 isa 指针都会指向一个根元类 (root metaclass)。根元类 (root metaclass) 本身的 isa 指针指向自己，这样就行成了一个闭环。上面提到，一个对象能够接收的消息列表是保存在它所对应的类中的。在实际编程中，我们几乎不会遇到向元类发消息的情况，那它的 isa 指针在实际上很少用到。不过这么设计保证了面向对象的干净，即所有事物都是对象，都有 isa 指针。\n\n我们再来看看继承关系，由于类方法的定义是保存在元类 (metaclass) 中，而方法调用的规则是，如果该类没有一个方法的实现，则向它的父类继续查找。所以，为了保证父类的类方法可以在子类中可以被调用，所以子类的元类会继承父类的元类，换而言之，类对象和元类对象有着同样的继承关系。\n\n\n![class-diagram.jpg](http://upload-images.jianshu.io/upload_images/1391187-1561910e39925b20.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/400)\n\n[好的文章一](http://www.cocoachina.com/ios/20140715/9142.html)\n[好的文章二](http://blog.devtang.com/2013/10/15/objective-c-object-model/)\n[好的文章三](https://www.jianshu.com/p/f900de4a1495)\n[好的文章四](https://www.jianshu.com/p/d8a3cabeb3d5)\n","tags":["iOS"]},{"title":"static-inline-修饰函数","url":"%2F2023%2F08%2F11%2FiOS%2Fstatic-inline-%E4%BF%AE%E9%A5%B0%E5%87%BD%E6%95%B0%2F","content":"\n### 主要用来处理  短小精悍且调用次数多的代码封装成为内联函数\n\n``` objc\nstatic inline CGFloat const mainScreenHeight(){\n    return [UIScreen mainScreen].bounds.size.height;\n}\n```\n\n引入内联函数的目的是为了解决程序中函数调用的效率问题。 \n函数是一种更高级的抽象。它的引入使得编程者只关心函数的功能和使用方法，而不必关心函数功能的具体实现；函数的引入可以减少程序的目标代码，实现程序代码和数据的共享。但是，函数调用也会带来降低效率的问题，因为调用函数实际上将程序执行顺序转移到函数所存放在内存中某个地址，将函数的程序内容执行完后，再返回到转去执行该函数前的地方。这种转移操作要求在转去前要保护现场并记忆执行的地址，转回后先要恢复现场，并按原来保存地址继续执行。因此，函数调用要有一定的时间和空间方面的开销，于是将影响其效率。特别是对于一些函数体代码不是很大，但又频繁地被调用的函数来讲，解决其效率问题更为重要。引入内联函数实际上就是为了解决这一问题。 \n\n在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来进行替换。显然，这种做法不会产生转去转回的问题，但是由于在编译时将函数休中的代码被替代到程序中，因此会增加目标程序代码量，进而增加空间开销，而在时间代销上不象函数调用时那么大，可见它是以目标代码的增加为代价来换取时间的节省。\n1．内联函数可减少cpu的系统开销，并且程序的整体速度将加快，但当内联函数很大时，会有相反的作用，因此一般比较小的函数才使用内联函数．\n2．有两种内联函数的声明方法，一种是在函数前使用inline关见字，另一种是在类的内部定义函数的代码，这样的函数将自动转换为内联函数，而且没必要将inline放在函数前面．\n3．内联是一种对编译器的请求，下面这些情况会阻止编译器服从这项请求．\n如果函数中包含有循环，switch或goto语句，递归函数，含有static的函数．\n\n由此可以看出，内联函数和成员函数没什么区别，区别就在于怎样加快函数的执行速度而已。\n内联函数是浪费空间来节省时间的设置，因为函数的调用是很浪费时间的，写成内联函数可以在每次调用时用函数体内容代替函数调用，有点类似一个宏定义。当函数体语句较少，且没有复杂的循环语句，且调用次数较多时，就可以用内联函数。\n","tags":["iOS"]},{"title":"并行和并发解释（队列）","url":"%2F2023%2F08%2F01%2FiOS%2F%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E8%A7%A3%E9%87%8A%EF%BC%88%E9%98%9F%E5%88%97%EF%BC%89%2F","content":"\n*并发指的是一种现象，一种经常出现，无可避免的现象。它描述的是“多个任务同时发生，需要被处理”这一现象。它的侧重点在于“发生”。*\n*并行指的是一种技术，一个同时处理多个任务的技术。它描述了一种能够同时处理多个任务的能力，侧重点在于“运行”。*\n我们常说的concurrent队列值得是并发队列，并行队列是parallelism。\n主队列，并发队列，串行队列，全局队列\n\n串行队列（先进入队列的任务先出队列，每次只执行一个任务）\n并发队列（依然是“先入先出”，不过可以形成多个任务并发）\n主队列（这是一个特殊的串行队列，而且队列中的任务一定会在主线程中执行）\n\n![image.png](http://upload-images.jianshu.io/upload_images/1391187-fa61d31f351b7f9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n","tags":["iOS"]},{"title":"裁剪图片","url":"%2F2023%2F08%2F01%2FiOS%2F%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87%2F","content":"\n``` objc\n- (UIImage *)croppedImage:(CGRect)bounds image:(UIImage *)origalImg{\n    CGImageRef imageRef = CGImageCreateWithImageInRect([origalImg CGImage], bounds);\n    UIImage *croppedImage = [UIImage imageWithCGImage:imageRef];\n    CGImageRelease(imageRef);\n    return croppedImage;\n}\n```\n","tags":["iOS"]},{"title":"人脸识别ios框架","url":"%2F2023%2F07%2F15%2FiOS%2F%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%2F","content":"通过查资料发现，像动态贴纸之类大多都是通过 人脸识别库 + GPUImage实现，人脸识别找到图片中的关键点（像嘴巴，鼻子，眼镜，眼睫毛等），确定好你要添加的坐标，通过GPUImage将原始图像和贴纸合成。\n发现几个不错的人脸识别的框架：\ncoreImage ： 系统自带，不太准确\n科大讯飞库：免费，还可以，关键点坐标跳动比较大\nface++：因为收费没有看，但是好多有名的软件集成了\n软虹：免费，但是支持不太好\nVisage Technologies：这个很牛逼，可以三维建模，但是收费\n\n","tags":["iOS"]},{"title":"load和initialize","url":"%2F2023%2F07%2F12%2FiOS%2Fload%E5%92%8Cinitialize%2F","content":"\n``` objc\n+ (void)load{\n    NSLog(@\"load Animal\");\n}\n```\n\n``` objc\n+ (void)initialize\n{\n//如果子类不实现initialize（） - 运行时将调用继承的实现 - 或者如果子类显式调用[super initialize]，\n//则父类initialize实现可能会被多次调用。\n//为使父类只调用一次，应加以判断  if (self == [Animal class]) { }\n    if (self == [Animal class]) { \n        NSLog(@\"initialize animal\");\n    }\n}\n```\n\n``` objc\n                  +load                   +initialize\n调用时机        被添加到runtime时(app启动过程中，main函数调用前)     收到第一条消息前，如果该类未用到，则永远不调用\n\n调用顺序        父类->子类->分类          父类->子类\n\n调用次数        1次                        多次\n\n是否需要显式     否                          否\n调用父类实现              \n\n是否沿用         否                        是（如果子类未实现，调用父类实现，而父类也会调用一遍，就会导致父类实现调用多次，因此加以判断限制）\n父类的实现                       \n\n分类中的实现      类和分类都执行         覆盖类中的方法，只执行分类的实现\n```\n"},{"title":"内省","url":"%2F2023%2F06%2F19%2FiOS%2F%E5%86%85%E7%9C%81%2F","content":"*内省（Introspection）是面向对象语言和环境的重要特性，Objective-C和Cocoa在这方面做的很好。内省是对象自己检查自己做为运行时对象详细信息的一种能力。这些详细信息包括对象在继承树上的位置，对象是否遵循特定的协议，以及是否可以响应特定的消息。NSObject协议和类定义了很多内省方法，用于查询运行时信息，以便根据对象的特征进行识别。*\n\n灵活的使用内省能力可以让你的程序更稳定强大。内省可以避免错误地进行消息派发、对象相等的错误判断等问题。下面介绍内省的一些实用方法：\n```\n//返回实例变量的Class对象，与 + (Class)class 相同。\n- (Class)class\n\n//实例变量父类Class对象\n@property (readonly) Class superclass;\n\n//检查对象是否是那个类或者其继承类实例化的对象\n- (BOOL)isKindOfClass:(Class)aClass;\n\n//检查对象是否是那个类但不包括继承类而实例化的对象\n- (BOOL)isMemberOfClass:(Class)aClass;\n\n//检查对象是否符合协议，是否实现了协议中所有的必选方法。\n- (BOOL)conformsToProtocol:(Protocol *)aProtocol;\n\n//检查对象是否包含这个方法\n- (BOOL)respondsToSelector:(SEL)aSelector;\n\n//判断一个实例不继承自NSObject，如果返回NO就是继承自NSObject，反之返回YES\n- (BOOL)isProxy;\n```\n\n```\n//返回对象对应哈希值\n@property (readonly) NSUInteger hash;\n\n//检查两个对象是否相等\n- (BOOL)isEqual:(id)object;\n```\n两个对象比较是否相等(注意与==区别，本体性与相等性，NSObject直接比较指针(本体性),若子类要比较，则需重写该方法。\n如果你写的子类还需要添加到集合类型（NSDictionary，NSSet等）中去，hash方法也需要重写, 详情看[isEqual、==的区别， hash用法](https://www.jianshu.com/p/3204680260ba)\n\n","tags":["iOS"]},{"title":"apple source code","url":"%2F2023%2F06%2F02%2FiOS%2Fapple-source-code%2F","content":"\n[下载地址](https://opensource.apple.com/tarballs/)\n","tags":["iOS"]},{"title":"isEqual、==的区别，hash用法","url":"%2F2023%2F05%2F19%2FiOS%2FisEqual%E3%80%81%3D%3D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C-hash%E7%94%A8%E6%B3%95%2F","content":"\n##### 一、基本类型的比较\n==可以用来基本类型的比较，直接比较值是否相等\nisEqual方法在NSObject类里实现，只能用来比较两个NSObject对象。\n\n##### 2、对象类型的比较（NSObject）\n通过实例比较一下\n``` objc\nUIColor *color1 = [UIColor colorWithRed:0.5 green:0.5 blue:0.5 alpha:1.0];\nUIColor *color2 = [UIColor colorWithRed:0.5 green:0.5 blue:0.5 alpha:1.0];\nNSLog(@\"color1 == color2 = %@\", color1 == color2 ? @\"YES\" : @\"NO\");\nNSLog(@\"[color1 isEqual:color2] = %@\", [color1 isEqual:color2] ? @\"YES\" : @\"NO\");\n输出结果：\ncolor1 == color2 = NO\n[color1 isEqual:color2] = YES\n```\n  *首先，我们要对于 相等性 和 本体性 进行一下区分。\n当两个物体有一系列相同的可观测的属性时，两个物体可能是互相相等或者等价的。但这两个物体本身仍然是不同的 ，它们各自有自己的本体。在编程中，一个对象的本体和它的内存地址是相关联的。NSObject 使用 isEqual: 这个方法来测试和其他对象的相等性。在它的基类实现中，相等性检查本质上就是对本体性的检查。两个 NSObject 如果指向了同一个内存地址，那它们就被认为是相同的。*\n``` objc\n@implementation NSObject (Approximate)\n- (BOOL)isEqual:(id)object {\n  return self == object;\n}\n@end\n```\n==: 比较两个对象的内存地址是否相同,即对对象的本体性进行检测。\n对于isisEqual:查看一下官方文档描述\n``` objc\nIf two objects are equal, they must have the same hash value. This last point is particularly important if you define isEqual:\n in a subclass and intend to put instances of that subclass into a collection. Make sure you also define [hash\n] in your subclass.\n如果两个对象相等，他们必须有相同的哈希值。如果你重写了子类的isEqual:方法并且要把该子类对象添加到集合类型对象中去，一定要重写hash方法。\n```\n*对于 NSArray，NSDictionary 和 NSString 这种容器类来说，大家所期望的，同时也是更加有用的行为，应该是进行深层的相等性检查，对于集合中的每个成员都进行判断。\nNSObject 的子类在实现它们自己的 isEqual: 方法时，应该完成下面的工作：\n实现一个新的 isEqualTo__ClassName__ 方法，进行实际意义上的值的比较。\n重载 isEqual: 方法进行类和对象的本体性检查，如果失败则回退到上面提到的值比较方法。\n重载 hash 方法。*\n``` objc\n@interface Person : NSObject\n@property (nonatomic, copy) NSString *name;\n@property (nonatomic, strong) NSDate *birthday;\n@end\n```\n``` objc\n- (BOOL)isEqual:(id)object {\n    if (self == object) {\n        return YES;\n    }\n    if (![object isKindOfClass:[Person class]]) {\n        return NO;\n    }\n    return [self isEqualToPerson:(Person *)object];\n}\n\n- (BOOL)isEqualToPerson:(Person *)person {\n    if (!person) {\n        return NO;\n    }\n    BOOL haveEqualNames = (!self.name && !person.name) || [self.name isEqualToString:person.name];\n    BOOL haveEqualBirthdays = (!self.birthday && !person.birthday) || [self.birthday isEqualToDate:person.birthday];\n    return haveEqualNames && haveEqualBirthdays;\n}\n\n- (NSUInteger)hash {\n  return [self.name hash] ^ [self.birthday hash];\n}\n```\n##### 子类hash发放重写技巧\n**In reality, a simple XOR over the hash values of critical properties is sufficient 99% of the time(对关键属性的hash值进行位或运算作为hash值)\n对子类的关键属性的hash值进行位或运算作为该子类的hash值，99%都适用\n **\n\n*为什么要提供hash方法呢\n由于hash的特性，两个对象相等hash值必相等，两个对象hash值相等，对象不一定相等。\n为了优化判等的效率, 基于hash的NSSet和NSDictionary在判断成员是否相等时, 会这样做\nStep 1: 集成成员的hash值是否和目标hash值相等, 如果相同进入Step 2, 如果不等, 直接判断不相等\nStep 2: hash值相同(即Step 1)的情况下, 再进行对象判等, 作为判等的结果*\n\n##### 结尾：什么时候需要重写isEqual方法 和 hash方法\n```If two objects are equal, they must have the same hash value. This last point is particularly important if you define isEqual:in a subclass and intend to put instances of that subclass into a collection. Make sure you also define [hash] in your subclass. \n简而言之：\n当你的子类之间需要判断相等时，重写isEqual:方法\n<del>如果你写的子类还需要添加到集合类型（NSDictionary，NSSet等）中去，hash方法也需要重写</del>```\n\n参考\nhttp://nshipster.cn/equality/\nhttp://www.jianshu.com/p/915356e280fc\n\n","tags":["iOS"]},{"title":"runloop","url":"%2F2023%2F05%2F18%2FiOS%2Frunloop%2F","content":"\nRunloop-- 运行循环（死循环）\n\n目的：1、保证runloop所在线程不退出\n            2、负责监听事件（触摸 时钟  网络）\n\nsource：事件源\nsource1：系统内核事件\nsource0：非系统内核事件\n\nrunloop模式包含observer . source . timer\n","tags":["iOS"]},{"title":"NSProxy和NSObject","url":"%2F2023%2F04%2F19%2FiOS%2FNSProxy-%E5%92%8C-NSObject%2F","content":"###### NSObject 定义\n``` objc\n@interface NSObject <NSObject> {\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wobjc-interface-ivars\"\n    Class isa  OBJC_ISA_AVAILABILITY;\n#pragma clang diagnostic pop\n}\n\n+ (void)load;\n\n+ (void)initialize;\n- (instancetype)init;\n@end\n```\nNSObject还有众多分类，NSObject(NSKeyValueCoding)实现了kvc，NSObject(NSKeyValueObserving)实现了kvo等等功能。\n#### NSProxy定义\n``` objc\n@interface NSProxy <NSObject> {\n    Class\tisa;\n}\n+ (id)alloc;\n+ (id)allocWithZone:(nullable NSZone *)zone NS_AUTOMATED_REFCOUNT_UNAVAILABLE;\n+ (Class)class;\n\n- (void)forwardInvocation:(NSInvocation *)invocation;\n- (nullable NSMethodSignature *)methodSignatureForSelector:(SEL)sel NS_SWIFT_UNAVAILABLE(\"NSInvocation and related APIs not available\");\n- (void)dealloc;\n- (void)finalize;\n@property (readonly, copy) NSString *description;\n@property (readonly, copy) NSString *debugDescription;\n+ (BOOL)respondsToSelector:(SEL)aSelector;\n\n- (BOOL)allowsWeakReference NS_UNAVAILABLE;\n- (BOOL)retainWeakReference NS_UNAVAILABLE;\n@end\n```\n``` objc\nstruct objc_class {\n    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;\n}\n```\n>1.根据其没有父类和objc_class定义，可以判断NSObject，NSProxy皆为根类，且均遵守NSObject协议，NSObject协议描述了一个对象所应该具有的内省方法，系统构造类中顶级类已知发现就这两个，当然你也可以自己构造一个顶级类。\n2.NSProxy是个抽象类，由于实现的方法很少，因此大多数方法多可以被转发，而NSObject实现方法过多，方法可能会被直接调用，不会被转发。故NSProxy主要目的是用forwardInvocation:方法来进行消息转发。\n","tags":["iOS"]},{"title":"weak到底有什么用","url":"%2F2023%2F04%2F15%2FiOS%2Fweak%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%2F","content":"\n[链接](http://www.cocoachina.com/ios/20170328/18962.html)\n>weak是弱引用，所引用对象的计数器不会加一，并在引用对象被释放的时候自动被设置为nil。通常用于解决循环引用问题。\n\nRuntime维护了一个weak表(哈希表)，用于存储指向某个对象的所有weak指针。weak表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象的地址）数组。\n\n>weak 的实现原理可以概括一下三步：\n>1、初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。\n2、添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。\n3、释放时，调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。\n\nweak因为需要维护一份hash表，在初始化和释放时需要更多操作，因此耗费更多资源，只在必要时用weak。\n\n\n\n","tags":["iOS"]},{"title":"ARC 环境下打印计数器","url":"%2F2023%2F03%2F23%2FiOS%2FARC%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%89%93%E5%8D%B0%E8%AE%A1%E6%95%B0%E5%99%A8%2F","content":"\n``` objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n    Person *b;\n    {\n        Person *a = [[Person alloc] init];\n        b = a;\n        [self printCount:a];\n    }\n}\n\n- (void)printCount:(id)obj{\n    NSLog(@\"retain count = %ld\\n\",CFGetRetainCount((__bridge CFTypeRef)(obj)));\n}\n\n```\n\n//后经测试不是太准确\n","tags":["iOS"]},{"title":"提高ios性能Tip","url":"%2F2023%2F02%2F18%2FiOS%2F%E6%8F%90%E9%AB%98ios%E6%80%A7%E8%83%BDTip%2F","content":"\n##### NSDateFormatter\n\n###### NSDateFormatter 不是唯一一个创建的开销就很昂贵的类，但是它却是常用的、开销大到 Apple 会特别建议应该缓存和重复使用实例的一个。\n###### 一种通用的缓存 NSDateFormatter 的方法是使用 -[NSThread threadDictionary]（因为 NSDateFormatter 不是线程安全的）：\n\n``` objc\n+ (NSDateFormatter *)cachedDateFormatter {\n  NSMutableDictionary *threadDictionary = [[NSThread currentThread] threadDictionary];\n  NSDateFormatter *dateFormatter = [threadDictionary objectForKey:@\"cachedDateFormatter\"];\n    if (dateFormatter == nil) {\n        dateFormatter = [[NSDateFormatter alloc] init];\n        [dateFormatter setLocale:[NSLocale currentLocale]];\n        [dateFormatter setDateFormat: @\"YYYY-MM-dd HH:mm:ss\"];\n        [threadDictionary setObject:dateFormatter forKey:@\"cachedDateFormatter\"];\n    }\n    return dateFormatter;\n}\n```\n错误示例 每次转化都重新新建一个\n``` objc\n//将时间转化为MM-dd HH：mm格式\n- (NSString *)getTimeString:(double)timeString\n{\n    if (timeString < 10000) {\n        return @\"\";\n    }\n    NSDate *timeDate = [NSDate dateWithTimeIntervalSince1970:timeString];\n    NSDateFormatter *format = [[NSDateFormatter alloc] init];\n    \n    NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];\n    unsigned int unitFlag = NSYearCalendarUnit;\n    NSDate *nowDate = [NSDate date];\n    NSDateComponents *components = [calendar components:unitFlag fromDate:timeDate toDate:nowDate options:0];\n    \n    NSInteger years = [components year];\n    if (years > 0) {\n        [format setDateFormat:@\"yyyy-MM-dd HH:mm\"];\n    }else{\n        [format setDateFormat:@\"MM-dd HH:mm\"];\n    }\n    return [format stringFromDate:timeDate];\n}\n```\n","tags":["iOS"]},{"title":"深copy和浅copy","url":"%2F2023%2F01%2F12%2FiOS%2F%E6%B7%B1copy%E5%92%8C%E6%B5%85copy%2F","content":">在iOS中并不是所有的对象都支持copy，mutableCopy，遵守NSCopying 协议的类可以发送copy消息，遵守NSMutableCopying 协议的类才可以发送mutableCopy消息。\n\n*所谓浅拷贝，即单纯的地址拷贝，并不产生新的对象，而是对原对象的引用计数值加1；而深拷贝，即是对象拷贝，产生新的对象副本，拥有独立的内存空间，引用计数器为1。*\n####系统类对象copy/mutablecopy\n*我们常用的有NSString/NSMutableString、NSArray/NSMutableArray、NSDictionary/NSMutableDictionary、NSSet、NSMutableSet等系统类对象，下面我们来验证什么情况下是深拷贝，什么情况下是浅拷贝。*\n\n先看代码：\n######NSString和NSMutableString\n```\n//    1.NSString NSMutableString -> COPY\n    NSString *str = @\"abc\";\n    NSString *str1 = [str copy];\n    NSLog(@\"%p %p\",str,str1);\n    \n    NSMutableString *mStr = [[NSMutableString alloc] initWithString:@\"123\"];\n    NSMutableString *mStr1 = [mStr copy];\n    NSLog(@\"%p %p\",mStr,mStr1);\n    //打印结果\n    0x10b549068 0x10b549068\n    0x61000007c680 0xa000000003332313\n```\n*copy：NSString为浅复制，NSMutableString为深复制*\n```\n    NSString *str = @\"abc\";\n    NSString *str1 = [str mutableCopy];\n    NSLog(@\"%p %p\",str,str1);\n\n    NSMutableString *mStr = [[NSMutableString alloc] initWithString:@\"123\"];\n    NSMutableString *mStr1 = [mStr mutableCopy];\n    NSLog(@\"%p %p\",mStr,mStr1);\n    //打印结果\n    0x1077e9078 0x6100000778c0\n    0x610000077bc0 0x610000077c00\n```\n*mutableCopy：NSString , NSMutableString均为深复制*\n*\nNSString对象copy得到NSString对象\nNSMutableString对象copy得到NSString对象\n*\n######NSArray和NSMutableArray\n``` \n  NSArray *oldArr = @[@\"123\",@\"234\"];\n    NSLog(@\"数组地址%p\",oldArr);\n    for (NSString *str in oldArr) {\n        NSLog(@\"%p\",str);\n    }\n    NSArray *newCopyArr = [oldArr copy];\n    NSLog(@\"数组地址%p\",newCopyArr);\n    for (NSString *str in newCopyArr) {\n        NSLog(@\"%p\",str);\n    }\n    NSMutableArray *newMutableCopyArr = [oldArr mutableCopy];\n    NSLog(@\"数组地址%p\",newMutableCopyArr);\n    for (NSString *str in newMutableCopyArr) {\n        NSLog(@\"%p\",str);\n    }\n    //打印结果\n数组地址0x60000003f140\n0x10a858098\n 0x10a8580b8\n 数组地址0x60000003f140\n0x10a858098\n 0x10a8580b8\n 数组地址0x61800004b940\n 0x10a858098\n 0x10a8580b8\n```\n*由此可以知道，NSArray对象调用mutableCopy会重新新的可变数组对象，但是可变数组对象的元素并没有独立的内存空间，只是地址的复制而已，因此只是对数组进行了深拷贝，而对数组元素却是进行浅拷贝。这种情况叫做集合的单层深复制 (One-Level-Deep Copy)。*\n\n*经实验，对于集合类型（NSSet/NSMutableSet自然也是一样的），情况和NSArray/NSMutableArray是一样的。*\n######总结：\n   mutableCopy必定为深复制，复制得到的新对象为可变类型\n   copy对于不可变类型为浅复制，对于可变类型为深复制，复制后得到的新对象均为不可变类型\n","tags":["iOS"]},{"title":"NSString的内存管理及copy和strong修饰的不同","url":"%2F2023%2F01%2F07%2FiOS%2FNSString%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8F%8Acopy%E5%92%8Cstrong%E4%BF%AE%E9%A5%B0%E7%9A%84%E4%B8%8D%E5%90%8C%2F","content":"\nNSString是一个不可变的字符串对象。这不是表示这个对象声明的变量的值不可变，而是表示它初始化以后，你不能改变该变量所分配的内存中的值，但你可以重新分配该变量所处的内存空间。\n``` objc\nNSString *str1 = @\"abc\";\nNSLog(@\"%p\",str1);\n\nNSString *str2 = [NSString stringWithString:@\"abc\"];\nNSLog(@\"%p\",str2);\n\nNSString *str3= [NSString stringWithFormat:@\"abc\"];\nNSLog(@\"%p\",str3);\n\nNSString *str4 = [[NSString alloc] initWithString:@\"abc\"];\nNSLog(@\"%p\",str4);\n\n//结果\n0x10a688068\n0x10a688068\n0xa000000006362613\n0x10a688068\n```\n区别：1、2、4方法创建的内存地址一样，都指向一常量内存区。用stringWithFormat方法创建新分配内存空间，内存分布在堆区。\n这是因为苹果采用了字符串驻留的优化技术，它把一个不可变字符串对象的值拷贝给各个不同的指针，节省了大量内存，因此1.2.4都指向常量内存区。\n\n#### 让NSString类型的Property为Copy型和strong型区别\n``` objc\n@interface Person : NSObject\n@property (strong,nonatomic) NSString *name;\n@end\n```\n```\nNSMutableString *mStr = [[NSMutableString alloc] initWithString:@\"124\"];   Person *p1 = [[Person alloc] init];\np1.name = mStr;\n[mStr appendString:@\"abc\"];\nNSLog(@\"%@\",p1.name);\n//结果\n 124abc\n``` objc\n  当使用strong修饰NSString，并且源字符串为NSMutableString时，为浅复制（只copy了指针，即地址相同），操作源字符串，p1.name也发生改变 \n```\n    Person *p1 = [[Person alloc] init];\n    p1.name = mStr;\n//    [mStr appendString:@\"abc\"];\n    mStr = @\"123\";\n    NSLog(@\"%@\",p1.name);\n//结果\n 124\n``` objc\n当使用strong修饰NSString，并且源字符串为NSString时，为浅复制,但是由于源字符串的不可变性，对源字符串操作不会影响p1.name\n```\n@interface Person : NSObject\n@property (copy,nonatomic) NSString *name;\n@end\n```\n``` objc\n NSMutableString *mStr = [[NSMutableString alloc] initWithString:@\"124\"];\n//    NSString *mStr = [[NSString alloc] initWithString:@\"124\"];\n    Person *p1 = [[Person alloc] init];\n    p1.name = mStr;\n    [mStr appendString:@\"abc\"];\n    NSLog(@\"%@\",p1.name);\n//结果\n//124\n124\n``` \n*当使用copy修饰NSString，并且源字符串为NSMutableString时，为深复制,对源字符串修改，不会影响现在的字符串*\n\n**总结**：\n1、当源字符串为NSString时，使用strong和copy修饰，均为浅复制，没有区别\n2、当源字符串为NSMutableString时，strong为浅复制，copy为深复制\n\n","tags":["iOS"]},{"title":"NSTimer","url":"%2F2023%2F01%2F04%2FiOS%2FNSTimer%2F","content":">http://www.jianshu.com/p/9e7e8c806ea3\n\n<br>\n>Note in particular that run loops maintain\n strong references to their timers, so you don’t have to maintain your own strong reference to a timer after you have added it to a run loop.\n\n*timer已经被所加入的runloop强引用，你不需要再对它强引用,这样用weak修饰，invalidate之后就会置为nil*\n\n<br>\n>A timer is not a real-time mechanism; it fires only when one of the run loop modes to which the timer has been added is running and able to check if the timer’s firing time has passed. Because of the various input sources a typical run loop manages, the effective resolution of the time interval for a timer is limited to on the order of 50-100 milliseconds. If a timer’s firing time occurs during a long callout or while the run loop is in a mode that is not monitoring the timer, the timer does not fire until the next time the run loop checks the timer. Therefore, the actual time at which the timer fires potentially can be a significant period of time after the scheduled firing time. See also [Timer Tolerance](dash-apple-api://load?topic_id=1412393&language=occ#1667624).\n总结：**nstimer可能不会定时触发  定时时间间隔为2秒，t1秒添加成功，那么会在t2、t4、t6、t8、t10秒注册好事件，并在这些时间触发。假设第3秒时，执行了一个超时操作耗费了5.5秒，则触发时间是：t2、t8.5、t10，第4和第6秒就被跳过去了，虽然在t8.5秒触发了一次，但是下一次触发时间是t10，而不是t10.5。**\n\n<br>\n>Repeating Versus Non-Repeating Timers\nYou specify whether a timer is repeating or non-repeating at creation time. A non-repeating timer fires once and then invalidates itself automatically, thereby preventing the timer from firing again. By contrast, a repeating timer fires and then reschedules itself on the same run loop.\nA repeating timer always schedules itself based on the scheduled firing time, as opposed to the actual firing time. For example, if a timer is scheduled to fire at a particular time and every 5 seconds after that, the scheduled firing time will always fall on the original 5 second time intervals, even if the actual firing time gets delayed. If the firing time is delayed so far that it passes one or more of the scheduled firing times, the timer is fired only once for that time period; the timer is then rescheduled, after firing, for the next scheduled firing time in the future.\n\n*Repeating为No的timer fire一次即调用- invalidate方法，而yes的只要时机合适就会被触发，不管被延迟了多久*\n\n<br>\n>Once scheduled on a run loop, the timer fires at the specified interval until it is invalidated. A non-repeating timer invalidates itself immediately after it fires. However, for a repeating timer, you must invalidate the timer object yourself by calling its [invalidate()\n] method. Calling this method requests the removal of the timer from the current run loop; as a result, you should always call the [invalidate()\n] method from the same thread on which the timer was installed. Invalidating the timer immediately disables it so that it no longer affects the run loop. The run loop then removes the timer (and the strong reference it had to the timer), either just before the [invalidate()\n] method returns or at some later point. Once invalidated, timer objects cannot be reused.\n\n<br>\n>@property NSTimeInterval tolerance;\n默认是0，the timer may fire at any time between its scheduled fire date and the scheduled fire date plus the tolerance. The timer will not fire before the scheduled fire date. For repeating timers, the next fire date is calculated from the original fire date regardless of tolerance applied at individual fire times, to avoid drift.\n\n*scheduled time + tolerance > fire time  > scheduled  time *\n\n<br>\n>  -(void)invalidate;\nThis method is the only way to remove a timer from an [NSRunLoop\n] object. The NSRunLoop\nobject removes its strong reference to the timer, either just before the [invalidate\n] method returns or at some later point.\nIf it was configured with target and user info objects, the receiver removes its strong references to those objects as well.\n**You must send this message from the thread on which the timer was installed. If you send this message from another thread, the input source associated with the timer may not be removed from its run loop, which could prevent the thread from exiting properly.**\n\n*在哪个线程加入的runloop，在哪个线程将timer从runloop移除*\n","tags":["iOS"]}]